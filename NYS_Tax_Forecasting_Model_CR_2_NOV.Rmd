---
title: "R Notebook"
output: html_notebook
---

Ryan E. Kelly
CS 668 - Analytics Capstone
Prof Krystyn Gutu
13 November 2024
#CODE REVIEW 2



Good evening,

This section of the assignment is was dedicated to satisfying objective two of the project proposal. I am happy with the progress. I am admittedly submitting this second code review a day late because of the trouble I had with the data.(I discovered this while attempting to build the models for code review 2. I essentially had to recreate code review 1 to satisfy code review 2, which was a large undertaking to retrace my steps) Initially, I had used the data I found from the Bureau of Labor Statistics. Ironically, their API was not great because of the limited years of data offered. This wasn't about request size, just simply the years of data available. I first ran into this problem when I began drafting the first prediction models. The dilemma I had was pulling < 10 years of tax and economic data, which wasn't nearly enough to capture the full breadth of seasonal changes in the NYS tax structure. I had to revisit ALL of my data points to ensure that I could capture the largest time period possible for accurate analysis. My first model was off by 32% of current values.... back to the drawing board. 

The solution: The Federal Reserve Bank. The data upkeep by their St Louis division is fantastic. They use an R package called "fredr" to pull well maintained historical economic data. I may have went overkill on some of the dates, but I was determined to maximize the time window for the training sets of the models. Ultimately, the time period I settled on was 1996 - 2023 to predict known tax values for 2024. 

The juice was not worth the squeeze for population trends. These values were better incorporated within GDP, CPI, unemployment data, and prior tax history. As such, population data was scrapped, not to mention the census API I found was only giving me the current year, not historical data. (time is a resource)

My goal for code review 3, the final code review, is to solidify these base models and see if I can bring these error percentage points further down. I also want to visualize the performance metrics and create some imagery I will use in the scientific report and eventual presentation. I am satisfied with the current baseline state of the models and how close (or far) they are from the actual 2024 tax revenue. The three final models are 1. basic linear regression, 2. random forest, and 3. ETS. I moved away from the SARIMA / ARIMA model because I did not have enough granular data to predict seasonality. This also caused me to question if month to month seasonality would be important enough for a model that is predicting on an annual basis. If I worked in the NYS department of finance, perhaps I would have better access to month-to-month data and could predict income shortfalls based on historical performance. Nonetheless - I am truly interested to see how they predict NYS FY 2025 once it includes this upcoming late spring.


RK 



# DATASET 1 -  New York State GDP Data
Source: Federal Reserve Bank (St. Louis)
https://fred.stlouisfed.org/series/NYNQGSP
```{r}

library(fredr)

fredr_set_key("0200e442540c7e00b0062bbabaf750dd")

ny_gdp_data <- fredr(series_id = "NYNGSP")
colnames(ny_gdp_data) <- c("date", "series_id", "gdp_value", "realtime_start", "realtime_end")

ny_gdp_data$year <- as.numeric(format(ny_gdp_data$date, "%Y"))
ny_gdp_data$gdp_value <- ny_gdp_data$gdp_value / 1e6  # Converts to billions
ny_gdp_data <- ny_gdp_data[, c("year", "gdp_value")]

str(ny_gdp_data)
summary(ny_gdp_data)

```


```{r}
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", mar = c(5, 5, 4, 2) + 0.1)

year_range <- paste(min(ny_gdp_data$year), max(ny_gdp_data$year), sep = " - ")

plot(
  ny_gdp_data$year, ny_gdp_data$gdp_value,
  type = "b",
  col = "black",
  xlab = "Year",
  ylab = "GDP Value (Billions of Dollars)",
  main = paste("New York State GDP CY (", year_range, ")", sep = ""),
  pch = 19,
  lwd = 1,
  las = 1,
  cex.axis = 0.8,
  cex.lab = 1
)

# Add grid lines
grid(nx = NULL, ny = NULL, col = "gray", lty = "dotted")

```

# DATASET 2 -  New York State Unemployment Data
Source: Federal Reserve Bank (St. Louis)
https://fred.stlouisfed.org/series/NYNQGSP

```{r}
library(fredr)

fredr_set_key("0200e442540c7e00b0062bbabaf750dd")
ny_unemployment_data_raw <- fredr(series_id = "NYUR")



ny_unemployment_df <- data.frame(
  year = as.numeric(format(ny_unemployment_data_raw$date, "%Y")),
  period = format(ny_unemployment_data_raw$date, "%m"),  # month period
  period_name = format(ny_unemployment_data_raw$date, "%B"),
  unemployment_rate = ny_unemployment_data_raw$value
)

ny_unemployment_df <- subset(ny_unemployment_df, period != "13")

```

```{r}
# Creation of fiscal year variable based on NY fiscal year (April 1 - March 31)

ny_unemployment_df$fiscal_year <- ifelse(ny_unemployment_df$period %in% c("01", "02", "03"),
                                         ny_unemployment_df$year - 1,
                                         ny_unemployment_df$year)

# Calendar year averages
ny_annual_unemployment <- aggregate(unemployment_rate ~ year, data = ny_unemployment_df, FUN = mean)
colnames(ny_annual_unemployment)[2] <- "unemployment_CY"

# Fiscal year averages
ny_fiscal_unemployment <- aggregate(unemployment_rate ~ fiscal_year, data = ny_unemployment_df, FUN = mean)
colnames(ny_fiscal_unemployment)[2] <- "unemployment_FY"

ny_unemployment_data <- merge(ny_annual_unemployment, ny_fiscal_unemployment, 
                              by.x = "year", by.y = "fiscal_year", all = TRUE)
```


```{r}
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", mar = c(5, 5, 4, 2) + 0.1)

year_range <- paste(min(ny_unemployment_data$year), max(ny_unemployment_data$year), sep = " - ")


plot(
  ny_unemployment_data$year,
  ny_unemployment_data$unemployment_FY,
  type = "o",
  col = "black",
  lwd = 1,
  pch = 19,
  xaxt = "n",
  yaxt = "n",
  ylab = "Average Unemployment Rate (%)",
  xlab = "Fiscal Year",
  main = paste("New York State Average Unemployment Rate FY (", year_range, ")", sep = "")
)


axis(1, at = ny_unemployment_data$year, labels = ny_unemployment_data$year, las = 2)
axis(2, las = 1)


grid(nx = length(ny_unemployment_data$year), ny = NULL, col = "lightgray", lty = "dotted")

```


```{r}
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", mar = c(5, 5, 4, 2) + 0.1)

year_range <- paste(min(ny_unemployment_data$year), max(ny_unemployment_data$year), sep = " - ")

plot(
  ny_unemployment_data$year,
  ny_unemployment_data$unemployment_FY,
  type = "o",
  col = "black",
  lwd = 1,
  pch = 19,
  xaxt = "n",
  yaxt = "n",
  ylab = "Average Unemployment Rate (%)",
  xlab = "Fiscal Year",
  main = paste("New York State Average Unemployment Rate FY (", year_range, ")", sep = "")
)

axis(1, at = ny_unemployment_data$year, labels = ny_unemployment_data$year, las = 2)
axis(2, las = 1)

grid(nx = length(ny_unemployment_data$year), ny = NULL, col = "lightgray", lty = "dotted")


```


DATASET #3 - CPI Data - North Eastern US
Source: US Department of Labor - Bureau of Labor Statistics
https://www.bls.gov/regions/mid-atlantic/news-release/consumerpriceindex_northeast.htm

https://data.bls.gov/timeseries/CUUR0100SA0?amp%253bdata_tool=XGtable&output_view=data&include_graphs=true


```{r}
library(httr)
bls_api_key <- "85f2b89f6fd64218a8ef61270b0e8dc1" 
cpi_series_id <- "CUUR0100SA0" # Northeast US CPI


fetch_cpi_data <- function(start_year, end_year, series_id, api_key) {
  url <- paste0(
    "https://api.bls.gov/publicAPI/v2/timeseries/data/", series_id,
    "?registrationkey=", api_key,
    "&startyear=", start_year, "&endyear=", end_year
  )
  
  response <- GET(url)
  
  if (status_code(response) == 200) {
    result <- content(response, as = "parsed", type = "application/json")$Results$series[[1]]$data
    if (is.null(result)) stop("No data returned from API.")
    return(result)
  } else {
    stop("API request failed with status code: ", status_code(response))
  }
}

# The requests had to be separated to accommodate for size limitations. 
data_1990_2009 <- fetch_cpi_data(1990, 2009, cpi_series_id, bls_api_key)
data_2010_2023 <- fetch_cpi_data(2010, 2023, cpi_series_id, bls_api_key)


# Extract and clean up each dataset with checks for NULLs and empty fields
extract_values <- function(data) {
  years <- sapply(data, function(x) if (!is.null(x$year)) x$year else NA)
  periods <- sapply(data, function(x) if (!is.null(x$period)) x$period else NA)
  period_names <- sapply(data, function(x) if (!is.null(x$periodName)) x$periodName else NA)
  cpi_values <- sapply(data, function(x) if (!is.null(x$value)) x$value else NA)
  
  data.frame(
    year = as.numeric(years),
    period = periods,
    period_name = period_names,
    cpi_index = as.numeric(cpi_values)
  )
}

# Apply extraction function
northeast_cpi_1990_2009 <- extract_values(data_1990_2009)
northeast_cpi_2010_2023 <- extract_values(data_2010_2023)

# Combination of data frames
northeast_cpi_df <- rbind(northeast_cpi_1990_2009, northeast_cpi_2010_2023)
head(northeast_cpi_df)
tail(northeast_cpi_df)



```









```{r}

# Aggregate by calendar year
calendar_year_cpi <- aggregate(cpi_index ~ year, data = northeast_cpi_df, FUN = mean)

# Filter data for NYS fiscal year calculation and check if non-empty
fiscal_year_data <- subset(northeast_cpi_df, period_name %in% c("April", "May", "June", "July", "August", "September", "October", "November", "December", "January", "February", "March"))
if (nrow(fiscal_year_data) > 0) {
  # Aggregate for NYS Fiscal Year (April 1 - March 31)
  fiscal_year_cpi <- aggregate(cpi_index ~ year, data = fiscal_year_data, FUN = function(x) mean(x, na.rm = TRUE))
  
  # Adjust fiscal year labels to start in the previous year
  fiscal_year_cpi$year <- fiscal_year_cpi$year - 1
  
  # Merge Calendar Year and Fiscal Year data into a single dataframe
  ne_cpi_data <- merge(calendar_year_cpi, fiscal_year_cpi, by = "year", all = TRUE)
  colnames(ne_cpi_data) <- c("year", "cpi_calendar_year", "cpi_fiscal_year")
  
  head(ne_cpi_data)
  summary(ne_cpi_data)
} else {
  warning("Fiscal year data is empty after subsetting. Check period_name values.")
}


```



```{r}
par(las = 1)
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", mar = c(5, 5, 4, 2) + 0.1)
cpi_range <- range(ne_cpi_data$cpi_calendar_year, na.rm = TRUE)
ylim_upper <- cpi_range[2] + 10

plot(
  ne_cpi_data$year, ne_cpi_data$cpi_calendar_year, type = "o",
  col = "black", pch = 19, lty = 1, lwd = 1,
  xlab = "Year", ylab = "CPI Index (Calendar Year)",
  main = "Northeast Consumer Price Index (CPI) - CY(2010-2023)",
  ylim = c(cpi_range[1], ylim_upper)
)

grid(nx = NULL, ny = NULL, col = "gray", lty = "dotted")


```
```{r}

windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", mar = c(5, 5, 4, 2) + 0.1)

cpi_range_fy <- range(ne_cpi_data$cpi_fiscal_year, na.rm = TRUE)
ylim_upper_fy <- cpi_range_fy[2] + 10

plot(
  ne_cpi_data$year, ne_cpi_data$cpi_fiscal_year, type = "o",
  col = "black", pch = 19, lty = 1, lwd = 1,
  xlab = "Fiscal Year", ylab = "CPI Index (Fiscal Year)",
  main = "Northeast Consumer Price Index (CPI) - FY(2010-2022)",
  ylim = c(cpi_range_fy[1], ylim_upper_fy)
)

grid(nx = NULL, ny = NULL, col = "gray", lty = "dotted")

```

# DATASET 4 - New York State Tax Projections
Source: New York State Department of Finance
API Call
https://www.tax.ny.gov/research/stats/statistics/stat_fy_collections.htm


```{r}
library(httr)
library(jsonlite)
library(dplyr)

base_url <- "https://data.ny.gov/resource/cpjr-ezcj.json"

# This offset is necessary because the NYS API for tax pulls has a limit of 1000 lines. 
# The tax data has approximately 1,600 lines. This method is recommended by the NYS data contractor, and it doesn't require an API key!

fetch_data <- function(offset, limit = 1000) {
  url <- paste0(base_url, "?$limit=", limit, "&$offset=", offset)
  response <- GET(url)
  
  if (http_type(response) != "application/json") {
    stop("Failed to fetch data: ", status_code(response))
  }
  
  content <- content(response, as = "text", encoding = "UTF-8")
  data <- fromJSON(content, flatten = TRUE)  # flatten nested data for simplicity
  
  if (is.null(data) || length(data) == 0) {
    return(NULL)  # Return NULL if data is empty
  }
  
  return(as.data.frame(data))
}

# Initialize variables
ny_tax_data_raw <- data.frame()  # Renamed to ny_tax_data_raw
offset <- 0
limit <- 1000

# Loop to fetch all data
repeat {
  data <- fetch_data(offset, limit)
  
  # Break if no data was returned
  if (is.null(data) || nrow(data) == 0) break
  
  # Bind the new data to the existing data frame
  ny_tax_data_raw <- bind_rows(ny_tax_data_raw, data)
  
  # Update offset for next iteration
  offset <- offset + limit
}

# Check the final data frame
head(ny_tax_data_raw)  # Show the first few rows
summary(ny_tax_data_raw)


```


```{r}
# Ensure that amount_collected is numeric
ny_tax_data_raw$amount_collected <- as.numeric(ny_tax_data_raw$amount_collected)

# Aggregate amount_collected by fiscal_year for each specified tax category
sales_excise_use <- aggregate(amount_collected ~ fiscal_year, 
                              data = ny_tax_data_raw[ny_tax_data_raw$tax_category == "Sales, Excise and Use", ], 
                              sum, na.rm = TRUE)
other_taxes_fees <- aggregate(amount_collected ~ fiscal_year, 
                              data = ny_tax_data_raw[ny_tax_data_raw$tax_category == "Other Taxes and Fees", ], 
                              sum, na.rm = TRUE)
corporation_business <- aggregate(amount_collected ~ fiscal_year, 
                                  data = ny_tax_data_raw[ny_tax_data_raw$tax_category == "Corporation and Business", ], 
                                  sum, na.rm = TRUE)
personal_income <- aggregate(amount_collected ~ fiscal_year, 
                             data = ny_tax_data_raw[ny_tax_data_raw$tax_category == "Personal Income", ], 
                             sum, na.rm = TRUE)
property_transfer <- aggregate(amount_collected ~ fiscal_year, 
                               data = ny_tax_data_raw[ny_tax_data_raw$tax_category == "Property Transfer", ], 
                               sum, na.rm = TRUE)
total_collected <- aggregate(amount_collected ~ fiscal_year, 
                             data = ny_tax_data_raw[ny_tax_data_raw$tax_category == "Total", ], 
                             sum, na.rm = TRUE)

# Merge all totals by fiscal_year
ny_tax_data <- Reduce(function(x, y) merge(x, y, by = "fiscal_year", all = TRUE), 
                      list(sales_excise_use, other_taxes_fees, 
                           corporation_business, personal_income, 
                           property_transfer, total_collected))


colnames(ny_tax_data) <- c("fiscal_year", "sales_excise_use", 
                           "other_taxes_fees", "corporation_business", 
                           "personal_income", "property_transfer", 
                           "total_collected")

print(ny_tax_data)


```

```{r}
# Check for missing totals and calculate them for fiscal years 1995 to 2002
for (i in 1995:2002) {
  # Check if total_collected is missing or NA for the given fiscal year
  if (is.na(ny_tax_data$total_collected[ny_tax_data$fiscal_year == i])) {
    # Sum across the other categories for this fiscal year
    ny_tax_data$total_collected[ny_tax_data$fiscal_year == i] <- 
      with(ny_tax_data[ny_tax_data$fiscal_year == i, ],
           sales_excise_use + other_taxes_fees + 
           corporation_business + personal_income + 
           property_transfer)
  }
}

print(ny_tax_data)


```



```{r}
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", mar = c(5, 5, 4, 2) + 0.1, las = 1)

barplot_values <- barplot(
  ny_tax_data$total_collected / 1e9,
  names.arg = ny_tax_data$fiscal_year,
  col = "lightblue",
  xlab = "Fiscal Year",
  ylab = "Total State Collections (in billions USD)",
  main = "New York State Total Tax Revenues by FY (1995-2024)",
  las = 2,
  ylim = c(0, max(ny_tax_data$total_collected / 1e9) * 1.1),
  cex.names = 0.8        
)


grid(nx = NA, ny = NULL, col = "gray")
abline(h = seq(20, max(ny_tax_data$total_collected / 1e9), by = 20), col = "gray", lty = "dotted")


box()


```

##################### STEP 2 - MODEL BUILDING ##########################



```{r}
ny_gdp_data
ny_unemployment_data
ne_cpi_data
ny_tax_data

```

```{r}
# Adding fiscal year column for ease of merging
ny_gdp_data$fiscal_year <- ny_gdp_data$year
ny_unemployment_data$fiscal_year <- ny_unemployment_data$year
ne_cpi_data$fiscal_year <- ne_cpi_data$year

# Merging on fiscal year
ny_tax_forecast_data <- merge(ny_tax_data, ny_gdp_data[, c("fiscal_year", "gdp_value")], by = "fiscal_year", all.x = TRUE)
ny_tax_forecast_data <- merge(ny_tax_forecast_data, ny_unemployment_data[, c("fiscal_year", "unemployment_FY")], by = "fiscal_year", all.x = TRUE)
ny_tax_forecast_data <- merge(ny_tax_forecast_data, ne_cpi_data[, c("fiscal_year", "cpi_fiscal_year")], by = "fiscal_year", all.x = TRUE)


colnames(ny_tax_forecast_data) <- c("fiscal_year", "sales_excise_use", "other_taxes_fees", "corporation_business", 
                                    "personal_income", "property_transfer", "total_collected", "gdp_value", 
                                    "unemployment", "cpi")

# Impute missing values for historical data - these values were back filled from 1997 - I could have also manually put these in, but for ease of access with the API and the need to keep this consistant, I am using this approach. This should not greatly impact the model in any way. I will revist this next code review. 
ny_tax_forecast_data$gdp_value[ny_tax_forecast_data$fiscal_year == 1995] <- ny_tax_forecast_data$gdp_value[ny_tax_forecast_data$fiscal_year == 1997]
ny_tax_forecast_data$gdp_value[ny_tax_forecast_data$fiscal_year == 1996] <- ny_tax_forecast_data$gdp_value[ny_tax_forecast_data$fiscal_year == 1997]
ny_tax_forecast_data$cpi[ny_tax_forecast_data$fiscal_year == 2023] <- ny_tax_forecast_data$cpi[ny_tax_forecast_data$fiscal_year == 2022]

# Prepare the 2024 test data and handle missing values
test_data_2024 <- subset(ny_tax_forecast_data, fiscal_year == 2024)

# Forward-fill missing values with 2023 values for 2024 predictions. (Only 1 value is being forward filled for the reason described above. I will revist this next code review)
test_data_2024$gdp_value[is.na(test_data_2024$gdp_value)] <- ny_tax_forecast_data$gdp_value[ny_tax_forecast_data$fiscal_year == 2023]
test_data_2024$cpi[is.na(test_data_2024$cpi)] <- ny_tax_forecast_data$cpi[ny_tax_forecast_data$fiscal_year == 2023]

# View the prepared data
print(head(ny_tax_forecast_data))
print(test_data_2024)


```

##################### MODEL BUILDING ##########################

##################### MODEL ONE - LINEAR REGRESSION ##################### 

```{r}

# Linear Regression Model
training_data <- subset(ny_tax_forecast_data, fiscal_year < 2024)
model <- lm(total_collected ~ gdp_value + unemployment + cpi, data = training_data)

# Predict and Calculate Percent Error
predicted_2024 <- predict(model, newdata = test_data_2024)
actual_2024 <- test_data_2024$total_collected
percent_off <- abs(predicted_2024 - actual_2024) / actual_2024 * 100

# Print Results
cat("Model One: Linear Regression\n")
cat("Predicted 2024 Tax Revenue:", round(predicted_2024, 2), "\n")
cat("Actual 2024 Tax Revenue:", actual_2024, "\n")
cat("Percent Off:", round(percent_off, 2), "%\n")


```

##################### MODEL 2 - RANDOM FOREST #####################
```{r}
library(randomForest)

# Random Forest Model
training_data_rf <- subset(ny_tax_forecast_data, fiscal_year < 2024)
set.seed(123)
rf_model <- randomForest(total_collected ~ gdp_value + unemployment + cpi, 
                         data = training_data_rf, 
                         ntree = 500, 
                         mtry = 2, 
                         importance = TRUE)

# Predict and Calculate Percent Error
predicted_2024_rf <- predict(rf_model, newdata = test_data_2024)
percent_off_rf <- abs(predicted_2024_rf - actual_2024) / actual_2024 * 100

# Print Results
cat("Model Two: Random Forest Regression\n")
cat("Predicted 2024 Tax Revenue:", round(predicted_2024_rf, 2), "\n")
cat("Actual 2024 Tax Revenue:", actual_2024, "\n")
cat("Percent Off:", round(percent_off_rf, 2), "%\n")

# Variable Importance
cat("\nVariable Importance:\n")
print(importance(rf_model))

```

##################### MODEL 3 - EXPONENTIAL SMOOTHING MODEL- (REPLACEMENT FOR SARIMA) #####################
```{r}
library(forecast)

# Define Time Series and Fit ETS Model
tax_revenue_ts <- ts(ny_tax_data$total_collected[ny_tax_data$fiscal_year < 2024], 
                     start = 1995, frequency = 1)
ets_model <- ets(tax_revenue_ts)
summary(ets_model)

# Forecast for 2024
forecast_2024 <- forecast(ets_model, h = 1)
predicted_2024_ets <- as.numeric(forecast_2024$mean)
percent_off_ets <- abs(predicted_2024_ets - actual_2024) / actual_2024 * 100

# Print Results
cat("Model Three: ETS\n")
cat("Predicted 2024 Tax Revenue:", round(predicted_2024_ets, 2), "\n")
cat("Actual 2024 Tax Revenue:", actual_2024, "\n")
cat("Percent Off:", round(percent_off_ets, 2), "%\n")


```




